💻 Cursor Rules 配置：React Native + TypeScript 开发规范
📜 通用开发规范
语言规范
所有回复必须以中文开头，称呼用户为"帅哥："。

技术术语保持英文原文。

需求拆解策略
复杂功能按以下流程分解：

类型接口定义

UI 组件实现

业务逻辑封装

集成测试

每个功能点完成后应有阶段性报告。

TypeScript 类型安全
严格遵守 TS 规范：

TypeScript

// 完整定义组件 Props 类型
type ProductItemProps = {
  id: string;
  name: string;
  price: number;
  discount?: number; // 可选属性标注
  onPress: (id: string) => void;
};
组件扩展原则
新增功能必须：

通过可选 props 扩展组件功能。

使用高阶组件或 Hook 包装现有组件。

创建全新的原子化组件（仅当无法复用现有资源时）。

React Native 特定规则
严格遵守 RN 开发规范：

使用 React Navigation 进行路由管理。

样式优先使用 StyleSheet.create 方法。

像素单位统一使用 dp（密度无关像素）。

设计原则
遵循核心设计理念：

单一职责原则：例如 CartItem 组件只处理购物车单项逻辑。

KISS原则：避免过度工程化设计。

第一性原理：回归问题本质需求重新思考方案。

🛠 自动化执行策略
安全操作范围
自动执行操作类型：

Bash

npx eslint --fix
yarn tsc --noEmit
mkdir components/<NewComponent> && touch index.tsx
高风险操作（需人工确认）
需确认的关键变更：

AndroidManifest.xml 权限修改

导航配置变更 (navigation/AppStack.tsx)

全局状态结构调整 (store/rootReducer.ts)

变更影响分析
修改前执行依赖分析：

Bash

# 组件依赖关系分析命令
yarn deps:analyze components/ProductCard/index.tsx
⚛️ React Native 最佳实践
组件开发规范
标准组件结构：

Plaintext

components/
  ProductItem/
    index.tsx         # 主组件文件
    types.ts          # 类型定义
    styles.ts         # 样式定义
    useProductItem.ts # 逻辑Hooks
状态管理
状态更新规则：

TypeScript

// 禁止直接修改状态，使用 immutability 原则
setCartItems(prevItems => {
  return [...prevItems, newItem];
});
平台差异处理
Android 平台特例方案：

TypeScript

// Android BackHandler 控制
useEffect(() => {
  const backAction = () => {
    if (shouldBlockBack) return true;
    return false;
  };
  BackHandler.addEventListener('hardwareBackPress', backAction);

  return () =>
    BackHandler.removeEventListener('hardwareBackPress', backAction);
}, [shouldBlockBack]);
🧪 质量保障规范
错误边界处理
所有屏幕必须包裹错误边界：

JavaScript

<ErrorBoundary
  fallback={<ErrorScreen />}
  onReset={() => resetStore()}>
  <CheckoutScreen />
</ErrorBoundary>
加载状态管理
数据加载处理：

JavaScript

function ProductScreen() {
  const { data, loading, error } = useFetchProduct(id);

  return loading ? <Loader /> :
         error ? <ErrorRetry /> :
         <ProductDetails data={data} />;
}
性能优化
核心优化点：

使用 React.memo 包装复杂组件。

FlatList 配置 initialNumToRender 和 maxToRenderPerBatch。

用 useCallback 缓存事件处理函数。

📚 文档与维护
组件文档规范
组件文档结构：

Markdown

## ProductCard 组件

### Props

| 属性名     | 类型   | 必填 | 描述         |
| ---------- | ------ | ---- | ------------ |
| `productId` | string | 是   | 商品唯一标识 |

### 使用示例

```tsx
<ProductCard
  productId="p123"
  onSelect={handleSelect}
/>
变更日志
提交消息规范：

Plaintext

[Navigation] feat: 新增购物车底部安全区域适配
[iOS Fix] hotfix: 修复支付屏幕键盘遮挡问题
迁移兼容性
API 变更处理流程：

TypeScript

// 旧API兼容方案
const BackButton = ({ onPress }) => (
  <Button
    title="Back"
    onPress={onPress || defaultBackAction}
  />
);
🛠 工具链集成
自动优化规则
提交前自动执行（建议通过 package.json 配置 husky 等工具）：

JSON

// package.json
"scripts": {
  "precommit": "tsc --noEmit && eslint --fix .",
  "lint": "eslint . --ext .ts,.tsx,.js,.jsx --fix",
  "typecheck": "tsc --noEmit"
},
"husky": {
  "hooks": {
    "pre-commit": "yarn precommit"
  }
}
依赖管理
安装新依赖流程：

Bash

# 自动检查项目是否存在相同功能工具库 (需团队实现具体逻辑)
yarn check-conflict <new-package-name>
# 确认后执行安全安装
yarn add <package-name>@^1.2.3
# 运行依赖审计，确保没有已知漏洞
yarn audit
调试工具
开发辅助命令：

Bash

# 类型验证
yarn typecheck
# RN组件结构预览
yarn analyze:components
# 运行单元测试并生成覆盖率报告
yarn test --coverage
# 检查依赖包的许可证合规性
yarn licenses list --json
🚨 风险控制方案
代码保护策略
关键代码备份机制：

Bash

# 重要文件每次修改前自动备份
cp src/store/cartSlice.ts .backups/cartSlice_$(date +%s).ts
测试覆盖率
最小测试覆盖率要求：

Plaintext

Component Logic : >=80%
Critical Path   : >=95%
热修复策略
紧急修复流程：

Plaintext

1. 创建独立修复分支 (hotfix/xxx)，基于生产版本。
2. 仅修改必要文件。
3. 添加回归测试。
4. 请求紧急代码评审。
5. 快速验证后，合并并立即部署。
6. 修复完成后，将 hotfix 分支合并到开发分支，以保持代码同步。
🔧 推荐开发流程
新增功能流程
Plaintext

1. 定义接口类型 (types/feature.d.ts)。
2. 创建基础组件组件 (components/Feature)。
3. 封装逻辑Hook (hooks/useFeature)。
4. 集成到应用导航栈。
5. 添加测试用例，确保覆盖率达标。
6. 提交代码并进行自查。
7. 请求代码评审并等待通过。
缺陷修复流程
Plaintext

1. 通过日志定位问题文件。
2. 创建最小化复现用例。
3. 修改同时添加防护测试。
4. 验证其他组件无影响。
5. 提交代码并进行自查。
6. 请求代码评审并等待通过。